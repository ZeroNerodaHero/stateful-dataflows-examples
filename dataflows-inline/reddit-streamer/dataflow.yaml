apiVersion: 0.5.0
meta:
  name: reddit-reader
  version: 0.1.0
  namespace: reddit

config:
  converter: json

types:
  reddit-obj:
    type: object
    properties:
      subreddit: 
        type: string
      title: 
        type: string
      author: 
        type: string
      selftext: 
        type: string
      ups:
        type: u32
      permalink: 
        type: string
      id: 
        type: string
  reddit-obj-keyword:
    type: object
    properties:
      obj: 
        type: reddit-obj
      keywords: 
        type: string

topics:
  reddit-sub-posts:
    schema:
      value:
        type: reddit-obj
  reddit-nodup:
    schema:
      value:
        type: reddit-obj
  reddit-key:
    schema:
      value:
        type: string
  watched-post:
    schema:
      value:
        type: reddit-obj
services:
  dedup:
    sources:
      - type: topic
        id: reddit-sub-posts
    states:
      tracker:
        from: dedup-tracker.tracker
    transforms:
      - operator: filter
        run: |
          fn genfilter(obj : RedditObj) -> Result<bool> {
            let track = tracker();
            let trackrow = track.sql(&format!(
                "select * from `tracker` where `id` = '{}'", obj.id
            ))?;
            let rows = trackrow.rows()?;
            Ok(!rows.next())
          }
    sinks:
      - type: topic
        id: reddit-nodup
  dedup-tracker:
    sources:
      - type: topic
        id: reddit-nodup
    states:
      tracker: 
        type: keyed-state
        properties:
          key: 
            type: string
          value: 
            type: arrow-row
            properties:
              id:
                type: string
              subreddit:
                type: string
              selftext:
                type: string
              title:
                type: string
              ups:
                type: u32
              author:
                type: string
              permalink:
                type: string
    partition:
      assign-key:
        run: |
          fn map_post(post: RedditObj) -> Result<String> {
            Ok(post.id)
          }
      update-state:
        run: |
          fn track_read(post: RedditObj) -> Result<()> {
            let mut track = tracker();
            track.id= post.id;
            track.subreddit= post.subreddit;
            track.selftext = post.selftext;
            track.title = post.title;
            track.ups = post.ups;
            track.author = post.author;
            track.permalink = post.permalink;
            track.update()?;
            Ok(())
          }
  keyword-splitter:
    sources:
      - type: topic 
        id: reddit-nodup
    transforms: 
      - operator: map
        dependencies:
          - name: regex
            version: "1.10.0"
        run: |
          fn extract_keywords(post: RedditObj) -> Result< RedditObjKeyword > {
            use regex::Regex;
            use std::collections::HashSet;


            let re = Regex::new(r"\s+").unwrap(); 
            let mut ret = format!("{} {}",post.title,post.selftext);
            ret = ret.chars()
                .filter(|c| c.is_alphanumeric() || c.is_whitespace()) 
                .collect::<String>().to_lowercase();
            let keywords: HashSet<String> = ret
                .split_whitespace()
                .map(|s| s.to_string()).collect();
            let keywords = keywords.into_iter().collect::<Vec<_>>().join("#");

            Ok(RedditObjKeyword{
                obj: post,
                keywords: keywords,
            })
          }
    sinks:
      - type: topic
        id: reddit-key
        transforms:
          - operator: flat-map
            run: |
              fn send_key(post : RedditObjKeyword) -> Result<Vec<String> >{
                let ret: Vec<String> = post.keywords.split('#')
                            .map(|str| str.to_string()).collect();
                Ok(ret)
              }
      - type: topic
        id: watched-post
        transforms:
          - operator: filter-map
            run: |
              fn has_watched(post : RedditObjKeyword) -> Result<Option<RedditObj> >{
                use std::collections::HashSet;

                let keywordslist: Vec<String> = post.keywords.split('#')
                            .map(|str| str.to_string())
                            .collect();
                let watching_list = std::env::var("watching")?;
                let watched: Vec<String> = watching_list.split(',')
                            .map(|str| str.to_string()).collect();
                
                let set_key: HashSet<String> = keywordslist.iter().cloned().collect();
                let set_watched: HashSet<String> = watched.iter().cloned().collect();
                let inter: HashSet<String> = set_key.intersection(&set_watched).cloned().collect();

                if !inter.is_empty() {
                    return Ok(Some(post.obj));
                }
                Ok(None)
              }
  keyword-counter:
    sources:
      - type: topic 
        id: reddit-key
    states:
      tabkeywords:
        type: keyed-state
        properties:
          key: 
            type: string
          value: 
            type: u32
    partition:
      assign-key:
        run: |
          fn map_keyword(keyword: String) -> Result<String > {
            Ok(keyword)
          }
      update-state:
        run: |
          fn update_keyword(keyword: String) -> Result<()> {
            tabkeywords().increment(1);
            Ok(())
          }
